<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Site Helper</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            color: white;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .api-setup {
            background: rgba(255, 255, 255, 0.95);
            margin: 1rem 2rem;
            padding: 1rem;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .api-setup input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s;
        }

        .api-setup input:focus {
            outline: none;
            border-color: #667eea;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin: 0 2rem 2rem 2rem;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            max-height: 500px;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .user-message {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 4px;
        }

        .bot-message {
            background: white;
            color: #333;
            border: 1px solid #e1e1e1;
            border-bottom-left-radius: 4px;
        }

        .system-message {
            background: #e8f5e8;
            color: #2d5a2d;
            border: 1px solid #c3e6c3;
            text-align: center;
            margin: 0 auto;
            font-style: italic;
        }

        .file-preview {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 5px;
            font-size: 0.85rem;
        }

        .file-download {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            font-size: 0.85rem;
            transition: background 0.3s;
        }

        .file-download:hover {
            background: #218838;
        }

        .chat-input-container {
            padding: 1rem;
            background: white;
            border-top: 1px solid #e1e1e1;
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            padding: 0.75rem;
            background: #6c757d;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .file-input-label:hover {
            background: #5a6268;
        }

        .chat-input {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid #e1e1e1;
            border-radius: 8px;
            resize: none;
            font-family: inherit;
            font-size: 0.9rem;
            transition: border-color 0.3s;
        }

        .chat-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .send-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .send-button:hover:not(:disabled) {
            transform: translateY(-1px);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .loading {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #666;
            font-style: italic;
        }

        .loading::after {
            content: "‚è≥";
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .selected-file {
            background: #e8f4f8;
            border: 1px solid #bee5eb;
            padding: 0.5rem;
            border-radius: 5px;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        @media (max-width: 768px) {
            .header, .api-setup, .chat-container {
                margin-left: 1rem;
                margin-right: 1rem;
            }
            
            .message {
                max-width: 95%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü§ñ Gemini Site Helper</h1>
    </div>

    <div class="api-setup">
        <input type="password" id="apiKey" placeholder="Enter your Gemini API Key..." />
    </div>

    <div class="chat-container">
        <div class="chat-messages" id="chatMessages">
            <div class="message system-message">
                Welcome! I can help you with file conversions, text processing, and more. Just tell me what you need!
            </div>
        </div>
        
        <div class="chat-input-container">
            <input type="file" id="fileInput" class="file-input" multiple accept="*/*">
            <label for="fileInput" class="file-input-label" title="Upload files">üìé</label>
            
            <textarea id="chatInput" class="chat-input" placeholder="Type your message... (e.g., 'Convert this file to PDF')" rows="1"></textarea>
            
            <button id="sendButton" class="send-button">Send</button>
        </div>
    </div>

    <script>
        class GeminiSiteHelper {
            constructor() {
                this.apiKey = '';
                this.selectedFiles = [];
                this.conversationHistory = [];
                
                this.initializeElements();
                this.setupEventListeners();
                this.loadApiKey();
            }

            initializeElements() {
                this.apiKeyInput = document.getElementById('apiKey');
                this.chatMessages = document.getElementById('chatMessages');
                this.chatInput = document.getElementById('chatInput');
                this.fileInput = document.getElementById('fileInput');
                this.sendButton = document.getElementById('sendButton');
            }

            setupEventListeners() {
                this.apiKeyInput.addEventListener('input', () => {
                    this.apiKey = this.apiKeyInput.value;
                    localStorage.setItem('geminiApiKey', this.apiKey);
                });

                this.fileInput.addEventListener('change', (e) => {
                    this.handleFileSelection(e.target.files);
                });

                this.chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                this.chatInput.addEventListener('input', () => {
                    this.autoResizeTextarea();
                });

                this.sendButton.addEventListener('click', () => {
                    this.sendMessage();
                });
            }

            loadApiKey() {
                const savedKey = localStorage.getItem('geminiApiKey');
                if (savedKey) {
                    this.apiKey = savedKey;
                    this.apiKeyInput.value = savedKey;
                }
            }

            autoResizeTextarea() {
                this.chatInput.style.height = 'auto';
                this.chatInput.style.height = Math.min(this.chatInput.scrollHeight, 120) + 'px';
            }

            handleFileSelection(files) {
                this.selectedFiles = Array.from(files);
                this.displaySelectedFiles();
            }

            displaySelectedFiles() {
                const existingPreview = document.querySelector('.selected-file');
                if (existingPreview) {
                    existingPreview.remove();
                }

                if (this.selectedFiles.length > 0) {
                    const preview = document.createElement('div');
                    preview.className = 'selected-file';
                    preview.innerHTML = `
                        üìé Selected files: ${this.selectedFiles.map(f => f.name).join(', ')}
                        <button onclick="this.parentElement.remove(); siteHelper.selectedFiles = [];" style="float: right; background: none; border: none; color: #666; cursor: pointer;">‚úï</button>
                    `;
                    this.chatInput.parentElement.insertBefore(preview, this.chatInput.parentElement.firstChild);
                }
            }

            async sendMessage() {
                if (!this.apiKey.trim()) {
                    alert('Please enter your Gemini API key first.');
                    return;
                }

                const message = this.chatInput.value.trim();
                if (!message && this.selectedFiles.length === 0) return;

                const userMessage = message || 'I have attached files for you to process.';
                this.addMessage('user', userMessage);

                if (this.selectedFiles.length > 0) {
                    this.addFilePreview(this.selectedFiles);
                }

                this.chatInput.value = '';
                this.autoResizeTextarea();
                this.sendButton.disabled = true;

                const loadingMessage = this.addMessage('bot', '', true);

                try {
                    const response = await this.callGemini(userMessage, this.selectedFiles);
                    this.removeMessage(loadingMessage);
                    
                    // Process the response to detect function calls
                    await this.processGeminiResponse(response, userMessage);
                    
                } catch (error) {
                    this.removeMessage(loadingMessage);
                    this.addMessage('bot', `Error: ${error.message}`);
                } finally {
                    this.sendButton.disabled = false;
                    this.selectedFiles = [];
                    document.querySelector('.selected-file')?.remove();
                    this.fileInput.value = '';
                }
            }

            async processGeminiResponse(response, originalMessage) {
                // Check if Gemini suggests any function calls
                const text = response.toLowerCase();
                
                // PDF conversion detection
                if (text.includes('convert') && text.includes('pdf') && this.selectedFiles.length > 0) {
                    this.addMessage('bot', "I'll convert your file(s) to PDF now.");
                    await this.convertToPDF(this.selectedFiles);
                    return;
                }
                
                // Text extraction detection
                if ((text.includes('extract') && text.includes('text')) || 
                    (text.includes('read') && text.includes('content'))) {
                    this.addMessage('bot', "I'll extract the text content from your file(s).");
                    await this.extractTextFromFiles(this.selectedFiles);
                    return;
                }
                
                // Image analysis detection
                if (text.includes('analyze') && text.includes('image')) {
                    this.addMessage('bot', "I'll analyze the image(s) for you.");
                    await this.analyzeImages(this.selectedFiles);
                    return;
                }
                
                // Default response
                this.addMessage('bot', response);
            }

            async callGemini(message, files = []) {
                const systemPrompt = `You are a helpful assistant integrated into a web application. You can analyze user requests and determine what functions to call. 

Available functions:
- PDF conversion: Convert various file formats to PDF
- Text extraction: Extract text content from documents and images
- Image analysis: Analyze and describe images

When a user asks to convert files to PDF, respond with something like "I'll convert your file to PDF" and mention "convert pdf" in your response.
When asked to extract text, mention "extract text" in your response.
When asked to analyze images, mention "analyze image" in your response.

Analyze this user request and respond appropriately: "${message}"

If files are attached, consider what the user might want to do with them based on their message.`;

                const requestBody = {
                    contents: [{
                        parts: [{ text: systemPrompt }]
                    }],
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 1024,
                    }
                };

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${this.apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.statusText}`);
                }

                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            }

            async convertToPDF(files) {
                try {
                    const { jsPDF } = window.jspdf;
                    
                    for (const file of files) {
                        if (file.type.startsWith('text/') || file.name.endsWith('.txt')) {
                            // Text to PDF
                            const text = await this.readFileAsText(file);
                            const pdf = new jsPDF();
                            const lines = pdf.splitTextToSize(text, 180);
                            pdf.text(lines, 15, 15);
                            
                            const pdfBlob = pdf.output('blob');
                            this.downloadFile(pdfBlob, file.name.replace(/\.[^/.]+$/, '') + '.pdf');
                            
                        } else if (file.name.endsWith('.docx')) {
                            // DOCX to PDF (requires mammoth.js for text extraction)
                            const arrayBuffer = await this.readFileAsArrayBuffer(file);
                            const result = await mammoth.extractRawText({arrayBuffer});
                            
                            const pdf = new jsPDF();
                            const lines = pdf.splitTextToSize(result.value, 180);
                            pdf.text(lines, 15, 15);
                            
                            const pdfBlob = pdf.output('blob');
                            this.downloadFile(pdfBlob, file.name.replace(/\.[^/.]+$/, '') + '.pdf');
                            
                        } else if (file.type.startsWith('image/')) {
                            // Image to PDF
                            const img = await this.loadImage(file);
                            const pdf = new jsPDF();
                            
                            const pageWidth = pdf.internal.pageSize.getWidth();
                            const pageHeight = pdf.internal.pageSize.getHeight();
                            
                            const imgWidth = img.width;
                            const imgHeight = img.height;
                            const ratio = Math.min(pageWidth / imgWidth, pageHeight / imgHeight);
                            
                            const width = imgWidth * ratio;
                            const height = imgHeight * ratio;
                            
                            pdf.addImage(img.src, 'JPEG', 15, 15, width - 30, height - 30);
                            
                            const pdfBlob = pdf.output('blob');
                            this.downloadFile(pdfBlob, file.name.replace(/\.[^/.]+$/, '') + '.pdf');
                        }
                    }
                    
                    this.addMessage('system', `‚úÖ Successfully converted ${files.length} file(s) to PDF`);
                    
                } catch (error) {
                    this.addMessage('bot', `Error converting to PDF: ${error.message}`);
                }
            }

            async extractTextFromFiles(files) {
                try {
                    for (const file of files) {
                        let text = '';
                        
                        if (file.type.startsWith('text/')) {
                            text = await this.readFileAsText(file);
                        } else if (file.name.endsWith('.docx')) {
                            const arrayBuffer = await this.readFileAsArrayBuffer(file);
                            const result = await mammoth.extractRawText({arrayBuffer});
                            text = result.value;
                        }
                        
                        if (text) {
                            this.addMessage('bot', `Text extracted from ${file.name}:\n\n${text}`);
                        }
                    }
                } catch (error) {
                    this.addMessage('bot', `Error extracting text: ${error.message}`);
                }
            }

            async analyzeImages(files) {
                const imageFiles = files.filter(f => f.type.startsWith('image/'));
                
                if (imageFiles.length === 0) {
                    this.addMessage('bot', 'No image files found to analyze.');
                    return;
                }
                
                for (const file of imageFiles) {
                    const img = await this.loadImage(file);
                    this.addMessage('bot', `Image Analysis for ${file.name}:\n- Format: ${file.type}\n- Size: ${(file.size / 1024).toFixed(1)} KB\n- Dimensions: ${img.width} x ${img.height} pixels`);
                }
            }

            // Utility functions
            readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            readFileAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            loadImage(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            downloadFile(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            addMessage(type, content, isLoading = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}-message`;
                
                if (isLoading) {
                    messageDiv.innerHTML = '<div class="loading">Thinking</div>';
                } else {
                    messageDiv.textContent = content;
                }
                
                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                
                return messageDiv;
            }

            addFilePreview(files) {
                const previewDiv = document.createElement('div');
                previewDiv.className = 'file-preview';
                previewDiv.innerHTML = `üìé Attached: ${files.map(f => `${f.name} (${(f.size / 1024).toFixed(1)} KB)`).join(', ')}`;
                
                const lastMessage = this.chatMessages.lastElementChild;
                lastMessage.appendChild(previewDiv);
            }

            removeMessage(messageElement) {
                if (messageElement && messageElement.parentNode) {
                    messageElement.parentNode.removeChild(messageElement);
                }
            }
        }

        // Initialize the application
        const siteHelper = new GeminiSiteHelper();
    </script>
</body>
</html>
