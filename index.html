<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Menu Design Constructor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', Arial, sans-serif;
            background-color: #f5f5f5;
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .canvas {
            width: 800px;
            height: 1000px;
            background: white;
            position: relative;
            border: 1px solid #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            cursor: crosshair;
        }

        .text-element {
            position: absolute;
            cursor: move;
            border: 2px dashed transparent;
            padding: 4px;
            min-width: 20px;
            min-height: 20px;
            word-wrap: break-word;
            user-select: none;
        }

        .text-element:hover {
            border-color: #007bff;
        }

        .text-element.selected {
            border-color: #007bff;
            background: rgba(0, 123, 255, 0.1);
        }

        .text-element.editing {
            cursor: text;
            user-select: text;
        }

        .resize-handles {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #007bff;
            border: 1px solid white;
            border-radius: 50%;
            pointer-events: all;
            cursor: pointer;
        }

        .resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
        .resize-handle.n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .resize-handle.s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .resize-handle.w { top: 50%; left: -4px; transform: translateY(-50%); cursor: w-resize; }
        .resize-handle.e { top: 50%; right: -4px; transform: translateY(-50%); cursor: e-resize; }

        .section {
            margin-bottom: 25px;
        }

        .section h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }

        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .upload-area:hover {
            border-color: #007bff;
        }

        .upload-area.drag-over {
            border-color: #007bff;
            background: rgba(0, 123, 255, 0.1);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .control-group input,
        .control-group select,
        .control-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            text-align: var(--textbox-align, left);
        }

        .control-group input[type="range"] {
            margin: 5px 0;
        }

        .control-group input[type="color"] {
            width: 50px;
            height: 30px;
            padding: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            background: #0056b3;
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.secondary:hover {
            background: #545b62;
        }

        .btn.danger {
            background: #dc3545;
        }

        .btn.danger:hover {
            background: #c82333;
        }

        .export-area {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
        }

        .export-code {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        .coordinates {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .font-size-display {
            font-size: 12px;
            color: #666;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="section">
            <h3>üìÅ Background Image</h3>
            <div class="upload-area" id="uploadArea">
                <p>Drop an image here or click to select</p>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
            </div>
        </div>

        <div class="section">
            <h3>‚ûï Add Text</h3>
            <button class="btn" onclick="addTextElement()">Add Text Element</button>
        </div>

        <div class="section" id="textControls" style="display: none;">
            <h3>‚úèÔ∏è Text Properties</h3>
            
            <div class="control-group">
                <label>Text Content:</label>
                <textarea id="textContent" rows="3" placeholder="Enter your text..."></textarea>
            </div>

            <div class="control-group">
                <label>Text Alignment:</label>
                <select id="textAlign">
                    <option value="left">Left</option>
                    <option value="center">Center</option>
                    <option value="right">Right</option>
                    <option value="justify">Justify</option>
                </select>
            </div>

            <div class="control-group">
                <label>Font Family:</label>
                <select id="fontFamily">
                    <option value="Inter">Inter</option>
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Courier New">Courier New</option>
                </select>
            </div>

            <div class="control-group">
                <label>Font Size: <span class="font-size-display" id="fontSizeDisplay">16px</span></label>
                <input type="range" id="fontSize" min="8" max="72" value="16">
            </div>

            <div class="control-group">
                <label>Font Weight:</label>
                <select id="fontWeight">
                    <option value="normal">Normal</option>
                    <option value="bold">Bold</option>
                    <option value="100">100 - Thin</option>
                    <option value="300">300 - Light</option>
                    <option value="400">400 - Normal</option>
                    <option value="600">600 - Semi Bold</option>
                    <option value="700">700 - Bold</option>
                    <option value="900">900 - Black</option>
                </select>
            </div>

            <div class="control-group">
                <label>Text Color:</label>
                <input type="color" id="textColor" value="#000000">
            </div>

            <div class="control-group">
                <label>Letter Spacing:</label>
                <input type="range" id="letterSpacing" min="0" max="10" value="0" step="0.5">
            </div>

            <div class="control-group">
                <label>Line Height:</label>
                <input type="range" id="lineHeight" min="1" max="3" value="1.2" step="0.1">
            </div>

            <div class="control-group">
                <label>Width:</label>
                <input type="number" id="elementWidth" min="20" max="800" value="auto" placeholder="auto">
            </div>

            <div class="control-group">
                <label>Height:</label>
                <input type="number" id="elementHeight" min="20" max="200" value="auto" placeholder="auto">
            </div>

            <div class="coordinates" id="coordinates">Position: x: 0, y: 0</div>

            <button class="btn" onclick="duplicateSelectedElement()">Duplicate Element</button>
            <button class="btn danger" onclick="deleteSelectedElement()">Delete Element</button>
        </div>

        <div class="section">
            <h3>üß≤ Snap Settings</h3>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="snapEnabled" checked> Enable Snapping
                </label>
            </div>
            <div class="control-group">
                <label>Snap Distance: <span id="snapDistanceDisplay">10px</span></label>
                <input type="range" id="snapDistance" min="5" max="30" value="10">
            </div>
        </div>

        <div class="section">
            <h3>üì• Load Configuration</h3>
            <div class="control-group">
                <label>Paste Configuration JSON:</label>
                <textarea id="loadConfig" rows="4" placeholder="Paste your configuration JSON here..."></textarea>
            </div>
            <button class="btn" onclick="loadConfiguration()">Load Configuration</button>
        </div>

        <div class="section">
            <h3>üì§ Export</h3>
            <button class="btn secondary" onclick="exportConfiguration()">Export Configuration</button>
            <div class="export-area hidden" id="exportArea">
                <h4>Configuration:</h4>
                <div class="export-code" id="exportCode"></div>
                <button class="btn" onclick="copyToClipboard()">Copy to Clipboard</button>
            </div>
        </div>
    </div>

    <div class="canvas-container">
        <div class="canvas" id="canvas"></div>
    </div>

    <script>
        let selectedElement = null;
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStartData = {};
        let textElements = [];
let backgroundImage = 'Burgerip√§iv√§ 10.9-1_page-0001.jpg';
        let snapEnabled = true;
        let snapDistance = 10;
        let resizeHandles = null;

        // Snap settings
        document.getElementById('snapDistance').addEventListener('input', (e) => {
            snapDistance = parseInt(e.target.value);
            document.getElementById('snapDistanceDisplay').textContent = snapDistance + 'px';
        });

        document.getElementById('snapEnabled').addEventListener('change', (e) => {
            snapEnabled = e.target.checked;
        });

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('canvas');

        // Set default background image
        window.addEventListener('DOMContentLoaded', () => {
            if (backgroundImage) {
                canvas.style.backgroundImage = `url('${backgroundImage}')`;
                uploadArea.innerHTML = '<p>‚úÖ Default background image loaded!</p>';
            }
        });

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadImage(file);
            }
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                backgroundImage = e.target.result;
                canvas.style.backgroundImage = `url(${backgroundImage})`;
                uploadArea.innerHTML = '<p>‚úÖ Background image loaded!</p>';
            };
            reader.readAsDataURL(file);
        }

        // Load configuration function
        function loadConfiguration() {
            try {
                const configText = document.getElementById('loadConfig').value.trim();
                if (!configText) {
                    alert('Please paste a configuration first!');
                    return;
                }

                const config = JSON.parse(configText);
                
                // Clear existing elements
                textElements.forEach(el => el.element.remove());
                textElements = [];
                selectedElement = null;
                document.getElementById('textControls').style.display = 'none';

                // Set background if exists
                if (config.backgroundImage && backgroundImage) {
                    canvas.style.backgroundImage = `url(${backgroundImage})`;
                } else if (config.backgroundImage) {
                    uploadArea.innerHTML = '<p>‚ö†Ô∏è Background image needed: ' + config.backgroundImage + '</p>';
                }

                // Load elements
                config.elements.forEach(elementConfig => {
                    const element = document.createElement('div');
                    element.className = 'text-element';
                    element.textContent = elementConfig.text;
                    element.style.left = elementConfig.x + 'px';
                    element.style.top = elementConfig.y + 'px';
                    element.style.fontSize = elementConfig.fontSize + 'px';
                    element.style.fontFamily = elementConfig.fontFamily;
                    element.style.color = elementConfig.color;
                    element.style.fontWeight = elementConfig.fontWeight;
                    element.style.letterSpacing = elementConfig.letterSpacing + 'px';
                    element.style.lineHeight = elementConfig.lineHeight;
                    element.style.textAlign = elementConfig.textAlign || 'left';
                    // Handle width and height
                    if (elementConfig.width && elementConfig.width !== 'auto') {
                        element.style.width = elementConfig.width + 'px';
                    }
                    if (elementConfig.height && elementConfig.height !== 'auto') {
                        element.style.height = elementConfig.height + 'px';
                    }
                    const elementData = {
                        id: Date.now() + Math.random(),
                        element: element,
                        text: elementConfig.text,
                        x: elementConfig.x,
                        y: elementConfig.y,
                        fontSize: parseInt(elementConfig.fontSize),
                        fontFamily: elementConfig.fontFamily,
                        color: elementConfig.color,
                        fontWeight: elementConfig.fontWeight,
                        letterSpacing: parseFloat(elementConfig.letterSpacing),
                        lineHeight: parseFloat(elementConfig.lineHeight),
                        width: elementConfig.width || 'auto',
                        height: elementConfig.height || 'auto',
                        textAlign: elementConfig.textAlign || 'left'
                    };

                    textElements.push(elementData);
                    canvas.appendChild(element);
                    addElementEventListeners(element, elementData);
                });

                alert('Configuration loaded successfully!');
                document.getElementById('loadConfig').value = '';
                
            } catch (error) {
                alert('Error loading configuration: ' + error.message);
            }
        }

        // Add text element
        function addTextElement() {
    const element = document.createElement('div');
    element.className = 'text-element';
    element.textContent = 'New Text';
    element.style.left = '50px';
    element.style.top = '50px';
    element.style.fontSize = '16px';
    element.style.fontFamily = 'Inter';
    element.style.color = '#000000';
    element.style.fontWeight = 'normal';
    element.style.width = 'auto';
    element.style.height = 'auto';
    element.style.textAlign = 'left';
    const elementData = {
        id: Date.now(),
        element: element,
        text: 'New Text',
        x: 50,
        y: 50,
        fontSize: 16,
        fontFamily: 'Inter',
        color: '#000000',
        fontWeight: 'normal',
        letterSpacing: 0,
        lineHeight: 1.2,
        width: 'auto',
        height: 'auto',
        textAlign: 'left'
    };

            textElements.push(elementData);
            canvas.appendChild(element);
            selectElement(element, elementData);
            
            // Add event listeners
            addElementEventListeners(element, elementData);
        }

        function addElementEventListeners(element, elementData) {
            element.addEventListener('mousedown', (e) => {
                e.preventDefault();
                selectElement(element, elementData);
                startDragging(e, elementData);
            });

            element.addEventListener('dblclick', () => {
                element.classList.add('editing');
                element.contentEditable = true;
                element.focus();
            });

            element.addEventListener('blur', () => {
                element.classList.remove('editing');
                element.contentEditable = false;
                elementData.text = element.textContent;
                updateControls();
            });

            element.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    element.blur();
                }
            });
        }

        function selectElement(element, elementData) {
            // Remove selection from other elements
            document.querySelectorAll('.text-element').forEach(el => {
                el.classList.remove('selected');
            });
            
            hideResizeHandles();
            
            element.classList.add('selected');
            selectedElement = elementData;
            document.getElementById('textControls').style.display = 'block';
            updateControls();
            showResizeHandles();
        }

        function showResizeHandles() {
            if (!selectedElement) return;
            
            hideResizeHandles();
            
            resizeHandles = document.createElement('div');
            resizeHandles.className = 'resize-handles';
            
            const rect = selectedElement.element.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            resizeHandles.style.left = (selectedElement.x) + 'px';
            resizeHandles.style.top = (selectedElement.y) + 'px';
            resizeHandles.style.width = selectedElement.element.offsetWidth + 'px';
            resizeHandles.style.height = selectedElement.element.offsetHeight + 'px';
            
            const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'w', 'e'];
            handles.forEach(handleType => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${handleType}`;
                handle.dataset.handle = handleType;
                
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    startResize(e, handleType);
                });
                
                resizeHandles.appendChild(handle);
            });
            
            canvas.appendChild(resizeHandles);
        }

        function hideResizeHandles() {
            if (resizeHandles) {
                resizeHandles.remove();
                resizeHandles = null;
            }
        }

        function updateResizeHandles() {
            if (resizeHandles && selectedElement) {
                resizeHandles.style.left = selectedElement.x + 'px';
                resizeHandles.style.top = selectedElement.y + 'px';
                resizeHandles.style.width = selectedElement.element.offsetWidth + 'px';
                resizeHandles.style.height = selectedElement.element.offsetHeight + 'px';
            }
        }

        function updateControls() {
            if (!selectedElement) return;

    document.getElementById('textContent').value = selectedElement.text;
    document.getElementById('fontFamily').value = selectedElement.fontFamily;
    document.getElementById('fontSize').value = selectedElement.fontSize;
    document.getElementById('fontWeight').value = selectedElement.fontWeight;
    document.getElementById('textColor').value = selectedElement.color;
    document.getElementById('letterSpacing').value = selectedElement.letterSpacing;
    document.getElementById('lineHeight').value = selectedElement.lineHeight;
    document.getElementById('elementWidth').value = selectedElement.width === 'auto' ? '' : selectedElement.width;
    document.getElementById('elementHeight').value = selectedElement.height === 'auto' ? '' : selectedElement.height;
    document.getElementById('fontSizeDisplay').textContent = selectedElement.fontSize + 'px';
    document.getElementById('coordinates').textContent = `Position: x: ${selectedElement.x}, y: ${selectedElement.y}`;
    document.getElementById('textAlign').value = selectedElement.textAlign || 'left';
        }

        function startResize(e, handleType) {
            isResizing = true;
            resizeHandle = handleType;
            
            const rect = canvas.getBoundingClientRect();
            resizeStartData = {
                mouseX: e.clientX,
                mouseY: e.clientY,
                elementX: selectedElement.x,
                elementY: selectedElement.y,
                elementWidth: selectedElement.element.offsetWidth,
                elementHeight: selectedElement.element.offsetHeight
            };
            
            document.addEventListener('mousemove', handleResize);
            document.addEventListener('mouseup', stopResize);
        }

        function handleResize(e) {
            if (!isResizing || !selectedElement) return;
            
            const deltaX = e.clientX - resizeStartData.mouseX;
            const deltaY = e.clientY - resizeStartData.mouseY;
            
            let newWidth = resizeStartData.elementWidth;
            let newHeight = resizeStartData.elementHeight;
            let newX = resizeStartData.elementX;
            let newY = resizeStartData.elementY;
            
            switch (resizeHandle) {
                case 'se': // Southeast
                    newWidth = Math.max(20, resizeStartData.elementWidth + deltaX);
                    newHeight = Math.max(20, resizeStartData.elementHeight + deltaY);
                    break;
                case 'sw': // Southwest
                    newWidth = Math.max(20, resizeStartData.elementWidth - deltaX);
                    newHeight = Math.max(20, resizeStartData.elementHeight + deltaY);
                    newX = resizeStartData.elementX + deltaX;
                    break;
                case 'ne': // Northeast
                    newWidth = Math.max(20, resizeStartData.elementWidth + deltaX);
                    newHeight = Math.max(20, resizeStartData.elementHeight - deltaY);
                    newY = resizeStartData.elementY + deltaY;
                    break;
                case 'nw': // Northwest
                    newWidth = Math.max(20, resizeStartData.elementWidth - deltaX);
                    newHeight = Math.max(20, resizeStartData.elementHeight - deltaY);
                    newX = resizeStartData.elementX + deltaX;
                    newY = resizeStartData.elementY + deltaY;
                    break;
                case 'e': // East
                    newWidth = Math.max(20, resizeStartData.elementWidth + deltaX);
                    break;
                case 'w': // West
                    newWidth = Math.max(20, resizeStartData.elementWidth - deltaX);
                    newX = resizeStartData.elementX + deltaX;
                    break;
                case 's': // South
                    newHeight = Math.max(20, resizeStartData.elementHeight + deltaY);
                    break;
                case 'n': // North
                    newHeight = Math.max(20, resizeStartData.elementHeight - deltaY);
                    newY = resizeStartData.elementY + deltaY;
                    break;
            }
            
            // Apply the new dimensions and position
            selectedElement.x = Math.max(0, newX);
            selectedElement.y = Math.max(0, newY);
            selectedElement.width = newWidth;
            selectedElement.height = newHeight;
            
            selectedElement.element.style.left = selectedElement.x + 'px';
            selectedElement.element.style.top = selectedElement.y + 'px';
            selectedElement.element.style.width = newWidth + 'px';
            selectedElement.element.style.height = newHeight + 'px';
            
            updateResizeHandles();
            updateControls();
        }

        function stopResize() {
            isResizing = false;
            resizeHandle = null;
            document.removeEventListener('mousemove', handleResize);
            document.removeEventListener('mouseup', stopResize);
        }

        function startDragging(e, elementData) {
            if (isResizing) return; // Don't drag while resizing
            
            isDragging = true;
            const rect = canvas.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left - elementData.x;
            dragOffset.y = e.clientY - rect.top - elementData.y;
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDragging);
        }

        function handleDrag(e) {
            if (!isDragging || !selectedElement || isResizing) return;
            
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left - dragOffset.x;
            let y = e.clientY - rect.top - dragOffset.y;
            
            // Apply snapping if enabled
            if (snapEnabled) {
                const snapped = getSnappedPosition(x, y, selectedElement);
                x = snapped.x;
                y = snapped.y;
            }
            
            selectedElement.x = Math.max(0, Math.min(x, canvas.offsetWidth - selectedElement.element.offsetWidth));
            selectedElement.y = Math.max(0, Math.min(y, canvas.offsetHeight - selectedElement.element.offsetHeight));
            
            selectedElement.element.style.left = selectedElement.x + 'px';
            selectedElement.element.style.top = selectedElement.y + 'px';
            
            updateResizeHandles();
            updateControls();
        }

        // Snapping function
        function getSnappedPosition(x, y, currentElement) {
            let snappedX = x;
            let snappedY = y;

            textElements.forEach(element => {
                if (element.id === currentElement.id) return;

                const otherRect = {
                    left: element.x,
                    right: element.x + element.element.offsetWidth,
                    top: element.y,
                    bottom: element.y + element.element.offsetHeight,
                    centerX: element.x + element.element.offsetWidth / 2,
                    centerY: element.y + element.element.offsetHeight / 2
                };

                const currentRect = {
                    left: x,
                    right: x + currentElement.element.offsetWidth,
                    top: y,
                    bottom: y + currentElement.element.offsetHeight,
                    centerX: x + currentElement.element.offsetWidth / 2,
                    centerY: y + currentElement.element.offsetHeight / 2
                };

                // Horizontal snapping
                if (Math.abs(currentRect.left - otherRect.left) <= snapDistance) {
                    snappedX = otherRect.left;
                } else if (Math.abs(currentRect.right - otherRect.right) <= snapDistance) {
                    snappedX = otherRect.right - currentElement.element.offsetWidth;
                } else if (Math.abs(currentRect.left - otherRect.right) <= snapDistance) {
                    snappedX = otherRect.right;
                } else if (Math.abs(currentRect.right - otherRect.left) <= snapDistance) {
                    snappedX = otherRect.left - currentElement.element.offsetWidth;
                } else if (Math.abs(currentRect.centerX - otherRect.centerX) <= snapDistance) {
                    snappedX = otherRect.centerX - currentElement.element.offsetWidth / 2;
                }

                // Vertical snapping
                if (Math.abs(currentRect.top - otherRect.top) <= snapDistance) {
                    snappedY = otherRect.top;
                } else if (Math.abs(currentRect.bottom - otherRect.bottom) <= snapDistance) {
                    snappedY = otherRect.bottom - currentElement.element.offsetHeight;
                } else if (Math.abs(currentRect.top - otherRect.bottom) <= snapDistance) {
                    snappedY = otherRect.bottom;
                } else if (Math.abs(currentRect.bottom - otherRect.top) <= snapDistance) {
                    snappedY = otherRect.top - currentElement.element.offsetHeight;
                } else if (Math.abs(currentRect.centerY - otherRect.centerY) <= snapDistance) {
                    snappedY = otherRect.centerY - currentElement.element.offsetHeight / 2;
                }
            });

            return { x: snappedX, y: snappedY };
        }

        // Duplicate element function
        function duplicateSelectedElement() {
            if (!selectedElement) {
                alert('Please select an element to duplicate!');
                return;
            }

    const element = document.createElement('div');
    element.className = 'text-element';
    element.textContent = selectedElement.text;
    // Offset position for the duplicate
    const newX = selectedElement.x + 20;
    const newY = selectedElement.y + 20;
    element.style.left = newX + 'px';
    element.style.top = newY + 'px';
    element.style.fontSize = selectedElement.fontSize + 'px';
    element.style.fontFamily = selectedElement.fontFamily;
    element.style.color = selectedElement.color;
    element.style.fontWeight = selectedElement.fontWeight;
    element.style.letterSpacing = selectedElement.letterSpacing + 'px';
    element.style.lineHeight = selectedElement.lineHeight;
    element.style.textAlign = selectedElement.textAlign || 'left';
    // Copy width and height
    if (selectedElement.width !== 'auto') {
        element.style.width = selectedElement.width + 'px';
    }
    if (selectedElement.height !== 'auto') {
        element.style.height = selectedElement.height + 'px';
    }
    const elementData = {
        id: Date.now() + Math.random(),
        element: element,
        text: selectedElement.text,
        x: newX,
        y: newY,
        fontSize: selectedElement.fontSize,
        fontFamily: selectedElement.fontFamily,
        color: selectedElement.color,
        fontWeight: selectedElement.fontWeight,
        letterSpacing: selectedElement.letterSpacing,
        lineHeight: selectedElement.lineHeight,
        width: selectedElement.width,
        height: selectedElement.height,
        textAlign: selectedElement.textAlign || 'left'
    };

            textElements.push(elementData);
            canvas.appendChild(element);
            addElementEventListeners(element, elementData);
            
            // Select the new duplicate
            selectElement(element, elementData);
        }

        function stopDragging() {
            isDragging = false;
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDragging);
        }

        // Control event listeners
        document.getElementById('textContent').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.text = e.target.value;
                selectedElement.element.textContent = e.target.value;
                updateResizeHandles();
            }
        });

        document.getElementById('fontFamily').addEventListener('change', (e) => {
            if (selectedElement) {
                selectedElement.fontFamily = e.target.value;
                selectedElement.element.style.fontFamily = e.target.value;
                updateResizeHandles();
            }
        });

        document.getElementById('fontSize').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.fontSize = e.target.value;
                selectedElement.element.style.fontSize = e.target.value + 'px';
                document.getElementById('fontSizeDisplay').textContent = e.target.value + 'px';
                updateResizeHandles();
            }
        });

        document.getElementById('fontWeight').addEventListener('change', (e) => {
            if (selectedElement) {
                selectedElement.fontWeight = e.target.value;
                selectedElement.element.style.fontWeight = e.target.value;
                updateResizeHandles();
            }
        });

        document.getElementById('textColor').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.color = e.target.value;
                selectedElement.element.style.color = e.target.value;
            }
        });

        document.getElementById('letterSpacing').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.letterSpacing = e.target.value;
                selectedElement.element.style.letterSpacing = e.target.value + 'px';
                updateResizeHandles();
            }
        });

        document.getElementById('lineHeight').addEventListener('input', (e) => {
            if (selectedElement) {
                selectedElement.lineHeight = e.target.value;
                selectedElement.element.style.lineHeight = e.target.value;
                updateResizeHandles();
            }
        });

        document.getElementById('elementWidth').addEventListener('input', (e) => {
            if (selectedElement) {
                const value = e.target.value;
                if (value === '' || value === 'auto') {
                    selectedElement.width = 'auto';
                    selectedElement.element.style.width = 'auto';
                } else {
                    selectedElement.width = parseInt(value);
                    selectedElement.element.style.width = value + 'px';
                }
                updateResizeHandles();
            }
        });

        document.getElementById('elementHeight').addEventListener('input', (e) => {
            if (selectedElement) {
                const value = e.target.value;
                if (value === '' || value === 'auto') {
                    selectedElement.height = 'auto';
                    selectedElement.element.style.height = 'auto';
                } else {
                    selectedElement.height = parseInt(value);
                    selectedElement.element.style.height = value + 'px';
                }
                updateResizeHandles();
            }
        });

// Text alignment control
document.getElementById('textAlign').addEventListener('change', (e) => {
    if (selectedElement) {
        selectedElement.textAlign = e.target.value;
        selectedElement.element.style.textAlign = e.target.value;
    }
});

        function deleteSelectedElement() {
            if (selectedElement) {
                selectedElement.element.remove();
                textElements = textElements.filter(el => el.id !== selectedElement.id);
                hideResizeHandles();
                selectedElement = null;
                document.getElementById('textControls').style.display = 'none';
            }
        }

        function exportConfiguration() {
            const config = {
                backgroundImage: backgroundImage ? 'background.jpg' : null,
                canvasWidth: 800,
                canvasHeight: 1000,
                elements: textElements.map(el => ({
                    text: el.text,
                    x: el.x,
                    y: el.y,
                    fontSize: el.fontSize,
                    fontFamily: el.fontFamily,
                    color: el.color,
                    fontWeight: el.fontWeight,
                    letterSpacing: el.letterSpacing,
                    lineHeight: el.lineHeight,
                    width: el.width,
                    height: el.height
                }))
            };

            document.getElementById('exportCode').textContent = JSON.stringify(config, null, 2);
            document.getElementById('exportArea').classList.remove('hidden');
        }

        function copyToClipboard() {
            const code = document.getElementById('exportCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                alert('Configuration copied to clipboard!');
            });
        }

        // Canvas click to deselect
        canvas.addEventListener('click', (e) => {
            if (e.target === canvas) {
                document.querySelectorAll('.text-element').forEach(el => {
                    el.classList.remove('selected');
                });
                hideResizeHandles();
                selectedElement = null;
                document.getElementById('textControls').style.display = 'none';
            }
        });
    </script>
</body>
</html>
